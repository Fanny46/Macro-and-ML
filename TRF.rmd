library(dplyr)
library(glmnet)
library(randomForest)
library(readr)

data <- read_csv("2025-11-MD.csv", show_col_types = FALSE)

# =========================================================================
# PART 1: LOAD AND LABEL DATA

# Variable names
series <- colnames(data[,2:length(data)])

# Raw data
rawdata <- data[2:nrow(data),2:length(data)]

# Month/year of the final observation
final_date <- tail(data$sasdate, 1)
dates <- data$sasdate

# T = number of months in the sample
T <- length(dates)

# Starting dates for the out-of-sample evaluation
start_date = "1/1/1974";
# =========================================================================
# PART 2: PROCESS DATA

# 1. Prepare Missing Data
yt <- rawdata

# 2. Reduce Sample  to usable dates: remove first two months because some
# series have been first differenced
dates <- dates[2:length(dates)]

# 3. Remove Outliers
# Functions
remove_outliers <- function(X) {
  # =========================================================================
  # DESCRIPTION:
  # This function takes a set of series aligned in the columns of a matrix
  # and replaces outliers with the value NA.
  #
  # -------------------------------------------------------------------------
  # INPUT:
  #           X   = dataset (one series per column)
  #
  # OUTPUT:
  #           Y   = dataset with outliers replaced with NA
  #
  # -------------------------------------------------------------------------
  # NOTES:
  #           1) Outlier definition: a data point x of a series X(:,i) is
  #           considered an outlier if abs(x-median)>10*interquartile_range.
  #
  #           2) This function ignores values of NaN and thus is capable of
  #           replacing outliers for series that have missing values.
  #
  # =========================================================================
  
  # =========================================================================
  # Calculate median of each series
  #             We use the 'apply' function to calculate the median for each
  #             column (i.e., margin 2) of a matrix 'X'
  #             -'X': This is the matrix or data frame for which you want to calculate column-wise medians.
  #             -'2': This argument specifies that the operation should be applied to each column.
  #                 In R, 1 means rows, and 2 means columns.
  #             - stats::median: This is the function that will be applied to each column (or row) of the matrix.
  #               In this case, it's the median function from the stats package.
  #             - na.rm = TRUE: This argument specifies whether to remove missing values (NA) before applying
  #               the function. In this case, na.rm = TRUE means that any missing values in each column will be
  #               ignored when calculating the median.
  #  So, overall, this command is calculating the median of each column in the matrix X, ignoring any missing values
  #  in each column. The result will be a vector of median values, one for each column of the matrix.
  median_X <- apply(X, 2, stats::median, na.rm = TRUE)
  
  # Repeat median of each series over all data points in the series
  median_X_mat <- matrix(rep(median_X, nrow(X)), nrow = nrow(X),
                         ncol = ncol(X), byrow = TRUE)
  #             - rep(median_X, nrow(X)): The rep function is used to replicate the value median_X a certain number
  #               of times. In this case, it is replicated nrow(X) times, where nrow(X) is the number of rows in the
  #               matrix X. This creates a vector of repeated median values.
  #             - matrix(...): This function is then used to convert the repeated median vector into a matrix.
  #                 nrow = nrow(X): Specifies the number of rows in the resulting matrix, which is the same as the
  #                                 number of rows in the original matrix X.
  #                 ncol = ncol(X): Specifies the number of columns in the resulting matrix, which is the same as
  #                                 the number of columns in the original matrix X.
  #                 byrow = TRUE: This argument specifies that the values in the repeated median vector should be
  #                               filled into the matrix by rows. If byrow = FALSE (or not specified), the filling would be done by columns.
  # So, overall, this command creates a matrix where each row contains the same repeated median value, and the
  # number of rows and columns in the new matrix is the same as the number of rows and columns in the original
  # matrix.
  
  # Calculate quartiles
  Q <- apply(X, 2, stats::quantile, probs = c(0.25, 0.75), na.rm = TRUE)
  
  # Calculate interquartile range (IQR) of each series
  IQR <- Q[2,] - Q[1,]
  
  # Repeat IQR of each series over all data points in the series
  IQR_mat <- matrix(rep(IQR, nrow(X)), nrow = nrow(X),
                    ncol = ncol(X), byrow = TRUE)
  
  # Determine outliers
  Z <- abs(X - median_X_mat)
  outlier <- (Z > (10 * IQR_mat))
  
  # Replace outliers with NaN
  Y <- X
  Y[outlier] <- NA
  
  # Cleaned data
  outdata <- Y
  # We set the class attribute of the object outdata to be a combination of two classes: "data.frame" and "fredmd".
  # In R, an object can belong to multiple classes. The class function is used to query or set the class of an object.
  # In this case, it's setting the class of outdata to be both "data.frame" and "fredmd".
  #                               A "data.frame" is a collection of vectors of identical lengths. Each vector 
  #                               represents a column, and each vector can be of a different data type (e.g., 
  #                               characters, integers, factors).
  class(outdata) <- c("data.frame", "fredmd")
  return(outdata)
  
  # Print the number of outliers
  print("Number of outliers:", quote = FALSE)     # quote = FALSE: The quote argument in the print function controls
  # whether or not to print quotation marks around the character
  # string. When quote = FALSE, it means that the string will be
  # printed without quotation marks.
  print(sum(outlier, na.rm = TRUE), quote = FALSE)  # na.rm = TRUE: The na.rm argument is set to TRUE, which means
  # that any missing values (NA) in the vector or matrix will be
  # removed before calculating the sum.
  # If na.rm is set to FALSE or not specified, the presence of any
  # missing values would result in the sum being reported as NA.
}

result <- remove_outliers(yt)
# =========================================================================
start_sample <- which(dates == start_date)

# Number of time points to use in the estimation of the parameter: Rolling scheme
Jwind = start_sample

if (Jwind > start_sample) {
  stop("the rolling window cannot be larger than the first evaluation sample")
}

j0 <- start_sample - Jwind + 1

x_temp <- yt[j0:start_sample, ]   # The available data at the beginning of the out-of-sample evaluation exercise
x<- remove_outliers(x_temp)       # Remove outliers specific to this particular sample

# =========================================================================
# PART 3: DEFINE TARGET VARIABLES (I(1) TRANSFORMATION)

h <- 1                       # forecast horizon
p <- 6                       # number of lags
initial_window <- 180        # 15 years (monthly data)

# Identify key macro variables (FRED-MD mnemonics)
idx_IP  <- which(series == "INDPRO")
idx_EMP <- which(series == "PAYEMS")
idx_CP  <- which(series == "CPIAUCSL")

# Log-difference targets Y_{t+h} = log(Z_{t+h}) - log(Z_t)
Y_IP  <- log(yt[(h+1):TT, idx_IP])  - log(yt[1:(TT-h), idx_IP])
Y_EMP <- log(yt[(h+1):TT, idx_EMP]) - log(yt[1:(TT-h), idx_EMP])
Y_CP  <- log(yt[(h+1):TT, idx_CP])  - log(yt[1:(TT-h), idx_CP])

# Align predictors
X_base <- yt[1:(TT-h), ]

# =========================================================================
# PART 4: CREATE LAGGED PREDICTORS

create_lags <- function(X, p) {
  X_lag <- X
  for (lag in 1:p) {
    X_lag <- cbind(
      X_lag,
      dplyr::lag(X, lag)
    )
  }
  return(na.omit(X_lag))
}

X_lagged <- create_lags(X_base, p)

# Adjust targets accordingly
Y_IP  <- tail(Y_IP,  nrow(X_lagged))
Y_EMP <- tail(Y_EMP, nrow(X_lagged))
Y_CP  <- tail(Y_CP,  nrow(X_lagged))

# =========================================================================
# PART 5: LASSO TARGETING

lasso_targeting <- function(X, y, s) {
  
  fit <- cv.glmnet(
    as.matrix(X),
    y,
    alpha = 1,
    standardize = TRUE
  )
  
  beta <- coef(fit, s = "lambda.min")
  selected <- rownames(beta)[which(beta != 0)]
  selected <- setdiff(selected, "(Intercept)")
  
  if (length(selected) > s) {
    selected <- selected[1:s]
  }
  
  return(selected)
}

# =========================================================================
# PART 6: EXPANDING WINDOW FORECAST

s_grid <- c(5, 10, 20, 30, 50)

expanding_RF_TRF <- function(Y, X, h = 1, s_vec = c(5, 10, 20)) {
  
  T <- nrow(Y)
  MSFE <- matrix(NA, nrow = T - h, ncol = length(s_vec) + 1)
  colnames(MSFE) <- c("RF", paste0("TRF_", s_vec))
  
  for (t in seq_len(T - h)) {
    
    # ===============================
    # Expanding window
    y_train <- Y[1:t, 1, drop = TRUE]
    X_train <- X[1:t, ]
    
    y_test <- Y[t + h, 1]
    X_test <- X[t, , drop = FALSE]
    
    # ===============================
    # Ordinary RF (toujours estimable)
    rf <- randomForest(
      x = X_train,
      y = y_train,
      ntree = 500
    )
    
    y_hat_rf <- predict(rf, X_test)
    MSFE[t, "RF"] <- (y_test - y_hat_rf)^2
    
    # ===============================
    # ðŸ”’ CRITICAL GUARD FOR LASSO
    if (length(y_train) < 5 || is.na(sd(y_train, na.rm = TRUE)) || sd(y_train, na.rm = TRUE) < 1e-8) next
    
    # ===============================
    # Targeted RF via LASSO
    lasso <- glmnet::cv.glmnet(
      x = as.matrix(X_train),
      y = y_train,
      alpha = 1,
      standardize = TRUE   # explicite
    )
    
    beta <- as.numeric(coef(lasso, s = "lambda.min"))[-1]
    selected <- which(beta != 0)
    
    for (j in seq_along(s_vec)) {
      
      s <- s_vec[j]
      idx <- selected[seq_len(min(s, length(selected)))]
      
      if (length(idx) == 0) next
      
      rf_trf <- randomForest(
        x = X_train[, idx, drop = FALSE],
        y = y_train,
        ntree = 500
      )
      
      y_hat_trf <- predict(rf_trf, X_test[, idx, drop = FALSE])
      MSFE[t, paste0("TRF_", s)] <- (y_test - y_hat_trf)^2
    }
  }
  
  return(colMeans(MSFE, na.rm = TRUE))
}


# =========================================================================
# PART 7: RESULTS

results_IP  <- expanding_RF_TRF(Y_IP,  X_lagged, s_vec = s_grid)
results_EMP <- expanding_RF_TRF(Y_EMP, X_lagged, s_vec = s_grid)
results_CP  <- expanding_RF_TRF(Y_CP,  X_lagged, s_vec = s_grid)

results_IP
results_EMP
results_CP
